//DEVICE MANAGER MODULE
alias funcNum R1;
alias currPID R2;
if(funcNum == TERMINAL_WRITE) then
	alias word R3;
	//acquire terminal
	multipush(R1,R2,R3);
	funcNum = 8;
	call MOD_0;
	multipop(R1,R2,R3);
	//print
	print word;
	//release terminal
	multipush(R1,R2,R3);
	funcNum = 9;
	call MOD_0;
	multipop(R1,R2,R3);
	return;
endif;
if(funcNum == TERMINAL_READ) then
	alias waddr R3;
	//acquire terminal
	multipush(R1,R2,R3);
	funcNum = 8;
	call MOD_0;
	multipop(R1,R2,R3);
	//read, change state of current process, call scheduler
	read;
	[PROCESS_TABLE + currPID * 16 + 4] = WAIT_TERMINAL;
	multipush(R1,R2,R3);
	call MOD_5;
	multipop(R1,R2,R3);
	//convert logical word address into physical
	waddr = [PTBR + 2 * waddr / 512] * 512 + (waddr % 512);
	//store value in input buffer to waddr location
	[waddr] = [PROCESS_TABLE + currPID * 16 + 8];
	return;	
endif;
if(funcNum == DISK_LOAD) then
	alias pageNum R3;
	alias blockNum R4;
	//acquire disk (R2 already has currPID)
	multipush(R1,R2,R3,R4);
	R1 = 3;
	call MOD_0;
	multipop(R1,R2,R3,R4);
	//set Disk Status Table
	[DISK_STATUS_TABLE + 1] = 0;
	[DISK_STATUS_TABLE + 2] = pageNum;
	[DISK_STATUS_TABLE + 3] = blockNum;
	//issue load, change state, invoke scheduler
	load(pageNum,blockNum);
	[PROCESS_TABLE + currPID * 16 + 4] = WAIT_DISK;
	multipush(R1,R2,R3,R4);
	call MOD_5;
	multipop(R1,R2,R3,R4);
	return;
endif;
