//RESOURCE MANAGER MODULE
alias funcNum R1;
alias currPID R2;

if(funcNum == ACQUIRE_TERMINAL) then
	//busy wait
	while([TERMINAL_STATUS_TABLE] == 1) do
		//change STATE in PROCESS TABLE, save registers in use
		[PROCESS_TABLE + currPID * 16 + 4] = WAIT_TERMINAL;
		multipush(R1, R2);
		//call scheduler
		call MOD_5;
		//restore registers (when this process scheduled again)
		multipop(R1, R2);
	endwhile;
	//set STATUS, PID in Terminal Status Table
	[TERMINAL_STATUS_TABLE] = 1;
	[TERMINAL_STATUS_TABLE + 1] = currPID;
	return;
endif;

if(funcNum == RELEASE_TERMINAL) then
	if([TERMINAL_STATUS_TABLE + 1] != currPID) then
		//process trying to release terminal without acquiring
		R0 = -1;
		return;
	endif;
	//set STATUS as 0 to indicate release	
	[TERMINAL_STATUS_TABLE] = 0;
	//update STATE of waiting processes
	alias t R3;
	t = 0;
	alias process_table R4;
	process_table = PROCESS_TABLE;
	while(t < 16) do
		if([process_table + 4] == WAIT_TERMINAL) then
			[process_table + 4] = READY;
		endif; 
		process_table = process_table + 16;
		t = t + 1;
	endwhile;
	//save return value, return to caller
	R0 = 0;
	return;
endif;

if(funcNum == ACQUIRE_DISK) then
	while([DISK_STATUS_TABLE] == 1) do
		//while disk is busy, change state, invoke scheduler
		[PROCESS_TABLE + currPID * 16 + 4] = WAIT_DISK;
		multipush(R1,R2);
		call MOD_5;
		multipop(R1,R2);
	endwhile;
	//lock disk by setting status, pid in DST
	[DISK_STATUS_TABLE] = 1;
	[DISK_STATUS_TABLE + 4] = currPID;
	return;		
endif;
