alias funcNum R1;

if(funcNum == GET_FREE_PAGE) then
	alias currPID R2;
	currPID = [SYSTEM_STATUS_TABLE + 1];
	//increment WAIT_MEM_COUNT
	[SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] + 1;
	while([SYSTEM_STATUS_TABLE + 2] == 0) do
		//busy wait loop while MEM_FREE_COUNT is 0
		[PROCESS_TABLE + currPID * 16 + 4] = WAIT_MEM;
		//call scheduler
		multipush(R1,R2);
		call MOD_5;
		multipop(R1,R2);
	endwhile;
	//decrement WAIT_MEM_COUNT and MEM_FREE_COUNT
	[SYSTEM_STATUS_TABLE + 3] = [SYSTEM_STATUS_TABLE + 3] - 1;
	[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;
	//find a free page using memory free list
	alias freePage R0;
	freePage = 76;
	while(freePage < MAX_MEM_PAGE) do
		if([MEMORY_FREE_LIST + freePage] == 0) then
			[MEMORY_FREE_LIST + freePage] = 1;
			break;
		endif;
		freePage = freePage + 1;
	endwhile;
	return;
endif;	

if(funcNum == RELEASE_PAGE) then
	alias pageNum R2;
	[MEMORY_FREE_LIST + pageNum] = [MEMORY_FREE_LIST + pageNum] - 1;
	if([MEMORY_FREE_LIST + pageNum] == 0) then
		//page is free
		[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] + 1;
		alias i R3;
		i = 0;
		while(i < 16) do
			if([PROCESS_TABLE + i * 16 + 1] >= 0) then
				if([PROCESS_TABLE + i * 16 + 4] == WAIT_MEM) then
					[PROCESS_TABLE + i * 16 + 4] = READY;
				endif;
			endif;
			i = i + 1;
		endwhile;	
	endif;
	return;
endif;
