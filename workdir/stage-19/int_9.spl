alias userSP R0;
userSP = SP;
//save user stack, switch to kernel stack
[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;
//set MODE_FLAG to system call number of exec()
[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 9;

//get name of file from stack
alias fileName R1;
fileName = [[PTBR + 2 * (userSP-4) / 512] * 512 + ((userSP-4) % 512)];
//search INODE TABLE (memory copy) for file
alias idx R2;
alias flag R3;
idx = 0;
flag = -1;
while(idx < MAX_FILE_NUM) do
	if(fileName == [INODE_TABLE + idx * 16 + 1]) then
		if([INODE_TABLE + idx * 16] == EXEC) then
			flag = 0;	
			break;	
		endif;
	endif;
	idx = idx + 1;
endwhile;
if(flag == -1) then
	//file doesnt exist or not EXEC
	//set return value as -1, return to user mode
	[[PTBR + 2 * (userSP-1) / 512] * 512 + ((userSP-1) % 512)] = -1;
	[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 0;
	SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 13];
	ireturn;
endif;

alias UAPN R4;
UAPN = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11];
//call Exit Process function in Process Manager Module
multipush(R1,R2,R3,R4);
R1 = 3; R2 = [SYSTEM_STATUS_TABLE + 1];
call MOD_1;
multipop(R1,R2,R3,R4);

//reclaim deallocated User Area Page
[MEMORY_FREE_LIST + UAPN] = [MEMORY_FREE_LIST + UAPN] + 1;
[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;

//set SP, update STATE field, store INODE index
alias PID R5;
PID = [SYSTEM_STATUS_TABLE + 1];
SP = UAPN * 512 - 1;
[PROCESS_TABLE + PID * 16 + 4] = RUNNING;
[PROCESS_TABLE + PID * 16 + 7] = idx;

//initialize PER-PROCESS RESOURCE TABLE
alias c R7;
alias resource_table R8;
c = 0;
resource_table = UAPN * 512 + RESOURCE_TABLE_OFFSET;
while(c < 16) do
	[resource_table + c] = -1;
	c = c + 1;
endwhile;

//allocate new pages, setup Page Table entires of new process

//library
[PTBR + 0] = 63;
[PTBR + 1] = "0100";
[PTBR + 2] = 64;
[PTBR + 3] = "0100";

//Heap
[PTBR + 4] = -1;
[PTBR + 5] = "0000";
[PTBR + 6] = -1;
[PTBR + 7] = "0000";

//Stack
multipush(R1,R2,R3,R4,R5);
R1 = 1;
call MOD_2;
[PTBR + 16] = R0;
[PTBR + 17] = "0110";
call MOD_2;
[PTBR + 18] = R0;
[PTBR + 19] = "0110";
multipop(R1,R2,R3,R4,R5);

//Code
multipush(R1,R2,R3,R4,R5);
//call GET_CODE_PAGE to load first code block
R2 = [INODE_TABLE + idx * 16 + 8];
R1 = 5;
call MOD_2;
multipop(R1,R2,R3,R4,R5);
[PTBR + 8] = R0;
[PTBR + 9] = "0100";

//invalidate remaining code pages
[PTBR + 10] = -1;
[PTBR + 11] = "0000";
[PTBR + 12] = -1;
[PTBR + 13] = "0000";
[PTBR + 14] = -1;
[PTBR + 15] = "0000";

//initialize PER-PROCESS DISK MAP TABLE
[DISK_MAP_TABLE + PID * 10 + 0] = -1;
[DISK_MAP_TABLE + PID * 10 + 1] = -1;
[DISK_MAP_TABLE + PID * 10 + 2] = -1;
[DISK_MAP_TABLE + PID * 10 + 3] = -1;
[DISK_MAP_TABLE + PID * 10 + 4] = [INODE_TABLE + idx * 16 + 8];
[DISK_MAP_TABLE + PID * 10 + 5] = [INODE_TABLE + idx * 16 + 9];
[DISK_MAP_TABLE + PID * 10 + 6] = [INODE_TABLE + idx * 16 + 10];
[DISK_MAP_TABLE + PID * 10 + 7] = [INODE_TABLE + idx * 16 + 11];
[DISK_MAP_TABLE + PID * 10 + 8] = -1;
[DISK_MAP_TABLE + PID * 10 + 9] = -1;

//store entry point IP on top of user stack
[[PTBR + 16] * 512] = [[PTBR + 8] * 512 + 1];
//change SP, MODE_FLAG, return to user mode
SP = 8 * 512;
[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 9] = 0;
ireturn;
